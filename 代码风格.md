
# 规范 优雅 大方
> 任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。—— Martin Fowler

规范：符合主流代码编写规范
优雅：代码观感舒适，整齐
大方：代码易懂，易调试。

在开发过程中逐渐积累自己的代码风格。

# 命名规则
**名副其实**

好的名称一定是名副其实的，不需要注释解释即可明白其含义的。

**容易区分**

我们很容易就会写下非常相近的方法名，仅从名称无法区分两者到底有啥区别（eg. `getAccount()`与`getAccountInfo()`），这样在调用时也很难抉择要用哪个，需要去看实现的代码才能确定。

**可读的**

名称一定是可读的，易读的，最好不要用自创的缩写，或者中英文混写。

**足够短**

名称当然不是越长越好，应该在足够表达其含义的情况下越短越好。
 
## 大小写约定

根据标识符的使用情况，可以通过两种适当的方法将标识符大写：
```
PascalCasing

camelCasing
```

### PascalCasing命名法

用于除参数名称、字段之外的标识符，将每个单词的第一个字符大写：
```
SpatialNode

TaskNode
```

特殊情况当碰到标识符的首字母是缩略词时，则缩略词应该要大写，但此处的缩略词应是约定好被开发人员都知道的。例如：
```
WBSTaskNode

IOStream
```

### camelCasing命名法

用于参数名称、字段的标识符，将每个单词的第一个字符小写后续单词的首字符大写且字段应该以_下划线开头：
```
_spatialNode

_taskNode
```
特殊情况当碰到标识符的首字母是缩略词时，则缩略词应该要小写，但此处的缩略词应是约定好被开发人员都知道的。例如：
```
_wbsTaskNode

_ioStream
```
特殊情况当定义static静态字段时，下划线开头应该以s开头，例如：
```
s_spatialNode
```
##  通用名约定

### 选择易读的标识符名称且可读性优于简洁性：
```
正例：CanScrollHorizontally

反例：ScrollableX

X轴不一定特指水平方向
```

### 不要使用匈牙利表示法且不要使用与关键字冲突的名称

### 只在必要时使用缩写词
```
正例：GetWindowWidth

反例：GetWinWidth
```
### 使用在语义上有意义的名称且不是特定语言的关键字名称
```
正例：GetLength

反例：GetLong
```
## 类、结构和接口规则

- 使用PascalCasing命名方式命名，且接口应加上字母I作为前缀

- 可以考虑在派生类后面加上基类的名字如：

ArgumentOutOfRangeException

- 不要在枚举类型名称中使用Enum作为后缀

## 命名资源约定

- 资源键使用PascalCasing方式命名

- 命名应是描述性的而非简单缩略标识

# 格式

**垂直格式**

通常一行只写一个表达式或者子句。一组代码代表一个完整的思路，不同组的代码中间用空行间隔。

# 注释

**别给糟糕的代码加注释，重构他**

注释不能美化糟糕的代码。当企图使用注释前，先考虑是否可以通过调整结构，命名等操作，消除写注释的必要，往往这样做之后注释就多余了。

**好的注释提供信息、表达意图、阐释、警告**

我们经常遇到这样的情况：注释写的代码执行逻辑与实际代码的逻辑并不符合。大多数时候都是因为代码变化了，而注释并没有跟进变化。所以，注释最好提供一些代码没有的额外信息，展示自己的设计意图，而不是写具体如何实现。

**删除掉注释的代码**

git等版本控制已经帮我们记录了代码的变更历史，没必要继续留着过时的代码，注释的代码也会对阅读等造成干扰。

# 类型设计规则

**类和函数应短小，更短小**

类和函数都不应该过长（集团要求函数长度最多不能超过 80 行），过长的函数可读性一定差，往往也包含了大量重复的代码。
  
**函数只做一件事（同一层次的事）**

同一个函数的每条执行语句应该是统一层次的抽象。例如，我们经常会写一个函数需要给某个 DTO 赋值，然后再调用接口，接着返回结果。那么这个函数应该包含三步：DTO 赋值，调用接口，处理结果。如果函数中还包含了 DTO 赋值的具体操作，那么说明此函数的执行语句并不是在同一层次的抽象。

**参数越少越好**

参数越多的函数，调用时越麻烦。尽量保持参数数量足够少，最好是没有。

## 在类和结构之间选择

结构的分配和释放通常比类的分配和释放开销更低，大型类的赋值比大型结构的赋值开销更低，类是通过引用传递的，结构是通过值传递的。

- 如果类型的实例比较小并且通常生存期较短或者通常嵌入在其他对象中，则定义结构而不是类

- 在提供一些计算工具时应选择结构实现而不是类

## 抽象类设计

- 请勿在抽象类型中定义公共或受保护的内部构造函数

- 请在抽象类中定义受保护的或内部构造函数

- 提供至少一种继承自你交付的每个抽象类的具体类型，有助于他人理解

## 静态类设计

- 谨慎使用静态类

- 静态类应仅用在支持系统的核心类

- 请勿将静态类当作杂项垃圾桶

- 务必将静态类声明为密封、抽象并添加一个私有构造函数

## 接口设计

- 务必至少提供一种作为接口的实现的类型

- 务必为你定义的每个接口提供至少一个使用它的 API

- 切忌将成员添加到之前发布的接口中。

# 成员设计规则

## 成员重载

- 使用清晰明确描述性的参数名称

- 避免随意更改重载中的参数名称

- 务必使只有最长的重载成为虚方法

- 不要使用ref或out修饰符来重载成员

- 允许null要为可选自变量传递

## 属性设计

- 务必为所有属性提供合理的默认值

- 务必在属性 setter 引发异常时保留以前的值

- 避免从属性 getter 中引发异常

## 构造函数设计

- 构造函数务必最小，其不应执行太多工作

- 务必将静态构造函数设为私有

- 内联的静态字段应在静态构造函数中完成

- 尽可能提供简单，理想情况下是默认值的构造函数

## 虚成员设计

- 除非必要请勿使用虚成员

- 将可扩展性限制在绝对必要的情况

- 对于虚成员，更倾向使用受保护的可访问性而非公共可访问性

## 字段设计

- 请勿提供公共或受保护的实例字段

- 使用常量字段表示永不改变的常量

- 对预定义的对象实例使用公共的静态的 readonly 字段

## 参数设计

- 切忌使用保留参数，需要更多参数应该使用新的重载

- 务必在重写成员或实现接口成员时，在命名参数上保持一致

- 务必验证传递到公共、受保护或显式实现的成员的实参

- 务必验证 enum 形参

- 避免使用 out 或 ref 形参

- 务必把所有 out 参数放置在所有传值和 ref 参数之后

- 务必在重写成员或实现接口成员时，在命名参数上保持一致

# 异常设计准则

**错误处理很重要，但他不能搞乱代码逻辑**

错误处理应该集中在同一层处理，并且错误处理的函数最好不包含其他的业务逻辑代码，只需要处理错误信息即可。

**抛出异常时提供足够多的环境和说明，方便排查问题**

异常抛出时最好将执行的类名，关键数据，环境信息等均抛出，此时自定义的异常类就派上用场了，通过统一的一层处理异常，可以方便快速地定位到问题。

**特例模型可消除异常控制或者 null 判断**

大多数的异常都是来源于NPE，有时候这个可以通过 Null Object 来消除掉。

**尽量不要返回 null ，不要传 null 参数**

不返回 null 和不传 null 也是为了尽量降低 NPE 的可能性。

## 使用标准异常类型

- 尽量避免定义自定义异常类

- 如果需要定义自定义的异常，继承于ApplicationException且提供自定义的序列化功能

- 只抛出已经显式处理的异常

- 在捕获(catch)语句的抛出异常子句中(throw)，总是抛出原始异常维护原始错误的堆栈分配

- 不必每个方法都用try-catch。当特定的异常可能发生时才使用

  

# 使用准则

## 数组

- 在公共 API 中首选使用集合而不是数组

- 在低级 API 中使用数组，从而最大程度地减少内存消耗并最大程度地提高性能

- 切忌使用只读数组字段

- 考虑使用交错数组而不是多维数组

## 集合

- 请勿在公共 API 中使用弱类型集合

- 避免在公共API中使用Hashtable或Dictionary<TKey,TValue>,应该使用IDictionary、IDictionary <TKey, TValue>替代

- 集合作为参数的大多数成员使用 IEnumerable< T> 接口

-  在实现 IDictionary 或 IDictionary<TKey,TValue> 的抽象名称中使用“Dictionary”后缀

- 在实现 IEnumerable（或其任意后代）并表示项列表的类型名称中使用“Collection”后缀

## 特性

- 使用后缀“Attribute”命名自定义特性类

- 为自定义特性应用 AttributeUsageAttribute

- 为可选实参提供可设置的属性

- 提供构造函数参数来初始化与所需参数对应的属性

- 避免重载自定义特性构造函数

参考：云建信C#编码规范
[怎么编写规范代码](https://www.zhihu.com/question/26721180)

# 关于log
## 为什么需要日志

>因为项目上线后不允许你调试，你只能通过Log来分析问题。项目出问题时，你要能拿出Log证明自己负责的部分没有问题，如果是自己的问题，要从Log里快速找出错误原因。如果没有从Log里找出错误原因，那一定是一件很悲催的事情，特别是在bug不容易重现的情况下。
## 哪些地方打日志

>打log的目的是为了迅速排错或在有争议时拿出证据证明自己。基于这个目的，log不在多，只要抓住一切对自己有利的信息，就可以了。

## log级别与对应日志

>Log最常用的级别就是`DEBUG`，`INFO`，`WARN`，`ERROR`，其他的很少用。如何运用合适的Log级别也是非常重要的，在不该用ERROR的地方用了ERROR，可能会给你带来额外的麻烦。  
### ERROR：  

 ERROR是错误的意思，但不代表出现异常的地方就该打ERROR。我认为ERROR是相对程序正确运行来说的，如果出现了ERROR那就代表出问题了，开发人员必须要查一下原因，或许是程序问题，或许是环境问题，或许是理论上不该出错的地方出错了。总结就是：若这个地方出错了会产生bug就打ERROR，如果不需要解决就不要打ERROR。  
 
 举例来说，如果有一个接口。调用者传过来的参数不在你的接受范围内，在这种情况下你不能打ERROR，因为传什么值是用户决定的，并不影响程序正确运行。想象一下，如果你的服务器上有监控程序的话，检测到ERROR或WARN就报警，参数错误你也打ERROR，那运维人员会疯掉的。  
 
 如果做一个对讲机，在解析语音数据包时出错了，那就要打ERROR了，因为这个是理论上不该出错的地方，要不就是你的解析代码有问题，要不就是开发人员在拼凑语音包时存在问题，这个时候需要你来找出问题的原因。所以应该打ERROR。  
 
 ### WARN
 
 WARN是指出现了不影响程序正确运行的问题，WARN也是问题但不影响程序正常运行，如果WARN出现的过于频繁或次数太多，那就代表你要检查一下程序或环境或依赖程序是否真的出问题了。  
 
 假如你访问一个接口，设置了一个超时，超时之后会抛异常，你在try块里不该打ERROR也不该打INFO来无视它，这时你应该打WARN，紧紧是警告一下，如果超时过多那就该检查一下了，是不是对方接口有问题了或者是网络环境出问题了。  
 
 ### INFO和DEBUG
 
 ERROR和WARN是指有问题，而INFO和DEBUG就是指一般的信息了。在程序出问题时，如果这条log可以帮助你分析问题或查看程序的运行情况，那就应该打个INFO。如果仅仅是为了在调试阶段查看程序是否运行正确那就要打DEBUG。前边讨论的接口参数错误问题，就应该打个INFO了，调用者说你的接口总是返回错误代码，你可以告诉他，是他的哪个参数传错了
 
 # 文件名
 `libs`:librarys 用来存放第三方库
 `src`:source code 源代码
 `test`: 测试文件
 `docs`: 文档
 `utils、tools、helpers`: 工具代码
  `controllers、views、middlewares、models`: MVC对应的models、views、controllers, 还有中间件middlewares
  `router`: 路由
  `server`: 用来存放服务器代码
  `legacy`: 存放兼容的历史版本
  `config`: 配置文件
  `unit、spec`: 单元测试，一般放在`test`目录下
`assets、vendor` : 资源文件
`examples、demo`: 示例文件
`component`: 组件
`plugins`: 插件
`bin`: 命令脚本
`common`: 公用的文件
`core`: 核心文件  
